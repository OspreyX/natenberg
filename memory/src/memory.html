<html>
	<head>
		<title>Memory Barriers and the JVM</title>
		<style>
			.code{
				background-color: #CCCCCC;
				padding: 10px
			}
		</style>
	</head>
	<body>
		<p>
			This article is a crash coarse in memory barriers and the JVM.  Memory barriers, or fences, are 
			a class of processor instructions used to apply ordering limitations on memory 
			operations.  For this reason memory barriers have a fundamental impact on the performance and
			determinism of any multi-threaded application.  This is not an article about locks or atomic 
			operations per se.  Memory barriers are about an equally important element of 
			concurrent programming called visibility.
		</p>
		<p>
			Our first example is the WriterReader class.
		</p>
		<pre>
	class WriterReader{
	
	  public static volatile int shared = 0;
	
	  public static void main(String[] _){
	    Thread writer = new Thread(){
	      public void run(){
	        for(int i = 0; i < 10000; i++)
	          set(i);
	      }
	    };
	    Thread reader = new Thread(){
	      public void run(){
	        for(int i = 0; i < 10000; i++)
	          get();
	      }
	    };
	    writer.start();
	    reader.start(); 
	  }
	
	  private static void set(int newValue){ shared = newValue; }
	  
	  private static int get(){ return shared; }
	}
		</pre>
		<p>
			The main method of this class creates two threads.  The writer thread writes to a static volatile variable.
			The reader thread reads from that variable.  Ignore the for loops.  These are only used to trigger JIT compilation.
			To obtain the assembly language instructions for this program we have to first install a special
			debug version of the JVM.  The following will work for Linux.  Sun 
			<a target="new" href="http://download.java.net/jdk6/binaries/">has installers</a> for Solaris or Windows
			as well.
		</p>
		<div class="code">
			$ wget http://www.java.net/download/jdk6/6u18/promoted/b05/binaries/jdk-6u18-ea-bin-b05-linux-i586-debug-18_nov_2009.jar<br/>
			$ mv "jdk-6u18-ea-bin-b05-linux-i586-debug-18_nov_2009.jar?e=1258770582&h=67548292b3c14c86f56d40f66b94c302" jdk-6u18-ea-bin-b05-linux-i586-debug-18_nov_2009.jar<br/>
			$ java -jar jdk-6u18-ea-bin-b05-linux-i586-debug-18_nov_2009.jar<br/>
		</div>
		<p>
			Next we install a disassembler plugin. The Kenai project <a href="http://kenai.com/projects/base-hsdis/downloads" target="new">has binaries</a>
			for Solaris, Linux and BSD.  The <a href="http://hg.openjdk.java.net/jdk7/hotspot/hotspot/file/tip/src/share/tools/hsdis/" target="new">hsdis</a>
			plugin can be built from source for Windows. 
		</p>
		<div class="code">
			$ wget http://kenai.com/projects/base-hsdis/downloads/download/linux-hsdis-i386.so<br/>
			$ cp linux-hsdis-i386.so /usr/lib/jvm/java-6-openjdk/jre/lib/i386/server/<br/>
			$ cp linux-hsdis-i386.so /usr/lib/jvm/java-6-openjdk/jre/lib/i386/client/<br/>
			$ cp linux-hsdis-i386.so /usr/lib/jvm/java-6-openjdk/jre/lib/i386/cacao/<br/>
		</div>
		<p>
			Now we are ready to compile and run this program, capturing the assembly instructions for the static set method of the WriterReader class.
		</p>
		<div class="code">		
			$ /usr/lib/jvm/java-6-openjdk/bin/javac WriterReader.java<br/>
			$ /usr/lib/jvm/java-6-openjdk/jre/bin/java -XX:+UnlockDiagnosticVMOptions -XX:PrintAssemblyOptions=hsdis-print-bytes -Xbatch -XX:CompileCommand=print,WriterReader.set WriterReader
		</div>
		<p>
			The set method body translates to the instructions found between push and pop.
		</p>
		<pre>
  1: push   %ebp               ;...55
  2: mov    %esp,%ebp          ;...8bec
  3: sub    $0x18,%esp         ;...83ec18
  4: mov    $0x95ba54d0,%esi   ;...bed054ba 95
  5: mov    %ecx,0x148(%esi)   ;...898e4801 0000
  6: mfence                    ;...0faef0
  7: mov    %ebp,%esp          ;...8be5
  8: pop    %ebp               ;...5d
		</pre>
		<p>
			Keep in mind that we are now beyond the platform 
			independent source code of Java.  These instructions are specific to the hardware the program was run on, a multi-processing Intel Xeon E5410.  
			This short stream of instructions tells a long story.		
			The write to the shared volatile variable is on line five, and it is immediately followed by a memory barrier on line six.  
			The mfence instruction forces the processor to serialize all prior read and write memory operations.  (TODO this satisfies ... )
			A little background on hardware can help explain the consequences of this.
		</p>
		<h3>Determinism costs Latency</h3>
		<p>
			Memory latency is a major bottleneck.  A trip to main memory can cost in the neighborhood of 250 clock cycles on modern systems.
			Hardware manufacturers use a cache hierarchy to decrease latency costs of memory operations by 
			an order of magnitude.  These caches are write-back caches, as opposed to 
			write-through caches.  This means the value of a write operation does not have to be written all the way 
			out to main memory.  The processor instead places this operation in a buffer and is now obligated to perform this operation at a later time.  
			It is inaccurate to think of this buffer as a queue as the operations that accumulate in it do not execute in the order in which 
			they arrive.  This is usually a good thing, allowing the system to perform better.  But programs can behave non-deterministically when
			memory operations on shared mutable state are re-ordered.  
			For example it is possible for a thread to read a series of values in an order that is inconsistent with the order in which they were written by
			another thread.
		</p>
		<p>
			To prevent this the program can use a memory barrier.  When a memory barrier triggers a flush of all 
			pending memory operations, the processor has temporarily loses many major opportunities for optimization.  
			This performance hit is the cost that must be paid for correctness.
		</p>
		<h3>Avoiding costs with Fence Ellision</h3>
		<p>
			The JVM is an amazingly efficient platform.  It is always looking for optimization opportunities.  When it can avoid a memory barrier, it does.
			Sometimes the consistency guarantees of the hardware memory model are greater than or equal to those of the Java memory model.  
			When this happens the JVM simply inserts a no op instead of an actual memory barrier.  For example, the memory consistency guarantees of an 
			x86 are strong enough to eliminate the need for a memory barrier when reading a volatile variable.
			The generated assembly instructions for the static get method of the WriterReader class actually demonstrates this.
		</p>
		<div class="code">
			$ /usr/lib/jvm/java-6-openjdk/jre/bin/java -XX:+UnlockDiagnosticVMOptions -XX:PrintAssemblyOptions=hsdis-print-bytes -Xbatch -XX:CompileCommand=print,WriterReader.get WriterReader
		</div>
<pre>
  1: push   %ebp               ;...55
  2: mov    %esp,%ebp          ;...8bec
  3: sub    $0x18,%esp         ;...83ec18
  4: mov    $0x95ba54d0,%eax   ;...b8d054ba 95
  5: mov    0x148(%eax),%eax   ;...8b804801 0000
  
  <span style="font-weight:bold">No Fence</span>
  
  6: mov    %ebp,%esp          ;...8be5
  7: pop    %ebp               ;...5d
</pre>	
		<p>
			The volatile read operation on line five is <i>not</i> chased with a fence.  In other words there is no performance penalty for a volatile 
			read instruction on an x86.
			On a uniprocessor system the JVM can insert a no op for <i>all</i> memory barriers because memory operations are already serialized.  
			The following instructions were captured from a runtime compilation of the set method of the WriterReader class using a VMWare workstation 
			image in uni-processor mode.
  		</p>
<pre>
  1: push   %ebp               ;...55
  2: mov    %esp,%ebp          ;...8bec
  3: sub    $0x18,%esp         ;...83ec18
  4: mov    $0x95ba54d0,%esi   ;...bed054ba 95
  5: mov    %ecx,0x148(%esi)   ;...898e4801 0000
  
  <span style="font-weight:bold">No Fence</span>
  
  6: mov    %ebp,%esp          ;...8be5
  7: pop    %ebp               ;...5d		
</pre> 		
		<p>
		Here we observe a volatile write on line five but the JVM does not chase it with a fence.
		</p>		
		<br/>
		<br/>
		<br/>
		<br/>
		<br/>
		<br/>
		<br/>
		<br/>
		<br/>
		<br/>
		<br/>
		<br/>		
		<br/>
		
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
	</body>
</html>